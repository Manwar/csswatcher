#!/usr/bin/perl -w -Ilib


use warnings;
use strict;

use Getopt::Long;
use File::Slurp qw/read_file write_file/;
use Path::Tiny;
use IO::Socket::INET;
use Log::Log4perl qw(:easy);
use Digest::MD5 qw/md5_hex/;
use PID::File;

use CSS::Watcher;

use constant AC_HTML_ATTRIBUTES            => 'html-attributes-list';
use constant SOCKET_FILE                   => '~/.emacs.d/ac-html-csswatcher/csswatcher.socket';
use constant LOG_FILE                      => '~/.emacs.d/ac-html-csswatcher/csswatcher.log';
use constant PID_FILE                      => '~/.emacs.d/ac-html-csswatcher/csswatcher.pid';
use constant HTML_STUFF                    => '~/.emacs.d/ac-html-csswatcher/completion/';

sub usage {

    my $Line;
    my ($Script) = ( $0 =~ m#([^\\/]+)$# );

    $Line = "-" x length( $Script );

    print << "EOT";

$Script
$Line
Monitor project and create completion for ac-html

  Usage:
    $0 [--help]
    $0 [options] OBJECT

    OBJECT......Directory or file, this script will find project home like projectile
    socket......Socket file, default
                @{[SOCKET_FILE]}
    restart.....Restart daemon

Daemon options:
    logfile.....Set log file for daemon, default
                @{[LOG_FILE]}
    outputdir...Output root directory where place generated files for ac-html
                @{[HTML_STUFF]}
    pidfile.....PID file for daemon, default
                @{[PID_FILE]}
    debug.......Debug level, default INFO. You can set
                OFF FATAL ERROR WARN INFO DEBUG TRACE ALL.

See also https://github.com/cheunghy/ac-html
EOT
}

my $socket_file = SOCKET_FILE;
my $log_file = LOG_FILE;
my $html_stuff_dir = HTML_STUFF;
my $pid_file = PID_FILE;
my $help = 0;
my $debug_level = 'INFO';
my $restart = 0;

GetOptions ( "socket=s" => \$socket_file,
             'logfile=i' => \$log_file,
             'outputdir=s' => \$html_stuff_dir,
             'debug=s' => \$debug_level,
             'pid=s' => \$pid_file,
             'restart' => \$restart,
             "help|?"  => \$help);


$socket_file = path( $socket_file );
$log_file = path( $log_file );
$html_stuff_dir = path( $html_stuff_dir );
$pid_file = path( $pid_file );

my $file = $ARGV[0];

if ($help) {
    usage();
    exit(0);
}

# try connect to daemon
my $probe = IO::Socket::UNIX->new(
     Type => SOCK_STREAM(),
     Peer => $socket_file,
);

# looks daemon not running, fork server
# when --reload param.
if (!defined $probe || $restart) {

    my $pid = fork();
    defined($pid) || die "Fork failed: $!";

    if (!$pid) {

        $socket_file->parent->mkpath;
        $log_file->parent->mkpath;
        $pid_file->parent->mkpath;

        # kill old daemon
        my $pid = PID::File->new(file => $pid_file);
        if ($pid->running) {
            kill "TERM", $pid->pid;
        }

        # start server
        unlink $log_file;
        unlink $socket_file;
        unlink $pid_file;

        die "can't create pid file"
            if ! $pid->create;
        $pid->guard;


        my $conf = qq(
    log4perl.rootLogger=$debug_level, Logfile
    log4perl.appender.Logfile          = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = $log_file
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.Logfile.layout.ConversionPattern = [\%d{HH:mm:ss}] %p{1} \%-20c{2} \%m\%n

  );
        Log::Log4perl::init( \$conf );

        my $server = IO::Socket::UNIX->new(
            Type => SOCK_STREAM(),
            Local => $socket_file,
            Listen => 1,
        );

        LOGDIE "Can't create socket for server" unless defined $server;

        my $watcher = CSS::Watcher->new;

        DEBUG "Ready for connections";

        while (1) {
            my $clientsocket = $server->accept();

            # read the data from the client
            my $task = <$clientsocket>;
            next unless defined $task;
            INFO " **** New Client Connected ****";

            # "WATCH: " command
            if (my ($watchobj) = $task =~/WATCH: (.+)/) {

                my ($project_dir, $classes, $ids) = $watcher->update ($watchobj);
                if (defined $project_dir) {
                    my $ac_html_stuff_dir = path ($html_stuff_dir)->child (md5_hex( ''.$project_dir ));
                    my $attrib_dir = path ($ac_html_stuff_dir)->child ('html-attributes-complete');

                    $attrib_dir->remove_tree({save => 0});
                    $attrib_dir->mkpath;

                    while ( my ( $tag, $class ) = each %{$classes} ) {
                        my $fname = File::Spec->catfile ($attrib_dir, $tag . '-class');
                        DEBUG "Write $fname";
                        write_file ($fname, map {
                            $_ . ' ' . $class->{$_} } keys %{$class});
                    }
                    while ( my ( $tag, $id ) = each %${ids} ) {
                        my $fname = File::Spec->catfile ($attrib_dir, $tag . '-id');
                        DEBUG "Write $fname";
                        write_file ($fname, map {
                            $_ . ' ' . $id->{$_} } keys %{$id});
                    }
                    DEBUG "Done writing. Reply to client.";
                    print $clientsocket "PROJECT: $project_dir\n";
                    print $clientsocket "ACSOURCE: $ac_html_stuff_dir\n";
                }
            }
        }
        $server->close();
        DEBUG "Exiting";
        exit;
    }
    sleep 2;                    # Wait few for daemon start well
}

# good, we connect to daemon, send job and print returned

if (($file // '') ne '') {
    my $client = IO::Socket::UNIX->new(
        Type => SOCK_STREAM(),
        Peer => $socket_file,
    );

    die "Can't create socket for client"
        unless defined $client;

    print $client "WATCH: $file\n";
    my $response = <$client>;
    if (defined $response) {
        print "$response\n";
    }
}


# if (!defined ($client)) {
#     unlink $socket_file;

#     my $server = IO::Socket::UNIX->new(
#         Type => SOCK_STREAM(),
#         Local => $socket_file,
#         Listen => 1,
#     );

#     die "Can't create socket for server" unless defined $server;

#     my $watcher = CSS::Watcher->new;

#     while (1) {
#         my $clientsocket = $server->accept();

#         print " **** New Client Connected ****\n";

#         # read the data from the client
#         my $task = <$clientsocket>;
#         if (my ($watchobj) = $task =~/WATCH:(.+)/) {

#             print "recieve job: \"$watchobj\"\n";

#             my ($project_dir, $classes, $ids) = $watcher->update ($watchobj);
#             if (defined $project_dir) {
#                 print $clientsocket "PROJECT: $project_dir\n";
#                 print "PROJECT: $project_dir\n";
#                 print Dumper \$classes;
#             }
#         }
#     }
#     $server->close();
# } else {
#     print "Connected\n";
#     print $client "WATCH:$file\n";
#     my $response = <$client>;
#     if (defined $response) {
#         print "$response\n";
#     }
# }


# my $attrib_dir = File::Spec->catfile ($ac_html_stuff_dir, 'html-attributes-complete');
# rmtree $attrib_dir;
# mkpath $attrib_dir;

# while ( my ( $tag, $class ) = each %classes ) {
#     my $fname = File::Spec->catfile ($attrib_dir, $tag . '-class');
#     write_file ($fname, map {
#         $_ . ' ' . $class->{$_} } keys %{$class});
# }
# while ( my ( $tag, $id ) = each %ids ) {
#     my $fname = File::Spec->catfile ($attrib_dir, $tag . '-id');
#     write_file ($fname, map {
#         $_ . ' ' . $id->{$_} } keys %{$id});
# }
