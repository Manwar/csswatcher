#!/usr/bin/perl -w -Ilib


use warnings;
use strict;

use Getopt::Long;
use FindBin;
use File::Spec;
use File::Slurp qw/read_file write_file/;
use File::Path qw/mkpath rmtree/;
use File::Basename;
use IO::Socket::INET;
use Log::Log4perl qw(:easy);

use CSS::Watcher;

use constant AC_HTML_ATTRIBUTES          => 'html-attributes-list';
use constant SOCKET_FILE => '~/.emacs.d/ac-html-csswatcher/csswatcher.socket';
use constant LOG_FILE => '~/.emacs.d/ac-html-csswatcher/csswatcher.log';

sub usage {

    my $Line;
    my ($Script) = ( $0 =~ m#([^\\/]+)$# );

    $Line = "-" x length( $Script );

    print << "EOT";

$Script
$Line
Monitor project and create completion for ac-html

  Usage:
    $0 [--help]
    $0 [options] OBJECT

    OBJECT......Directory or file, this script will find project home like projectile
    socket......Socket file, default
                @{[SOCKET_FILE]}
    logfile.....Set log file for daemon, default
                @{[LOG_FILE]}
See also https://github.com/cheunghy/ac-html
EOT
}

my $socket_file = SOCKET_FILE;
my $log_file = LOG_FILE;
my $help = 0;

GetOptions ( "socket=s" => \$socket_file,
             'logfile=i' => \$log_file,
             "help|?"  => \$help);


$socket_file = File::Spec->rel2abs($socket_file);
$log_file = File::Spec->rel2abs($log_file);

my $file = $ARGV[0];

if ($help || ($file // '') eq '') {
    usage();
    exit(0);
}

# try connect to daemon
my $client = IO::Socket::UNIX->new(
     Type => SOCK_STREAM(),
     Peer => $socket_file,
);

# looks daemon not running, fork server
if (!defined $client) {

    my $pid = fork();
    defined($pid) || die "Fork failed: $!";

    if (!$pid) {
        # start server
        mkpath dirname($socket_file);
        mkpath dirname($log_file);
        unlink $log_file;

        my $conf = qq(
    log4perl.rootLogger=INFO, Logfile
    log4perl.appender.Logfile          = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = $log_file
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.Logfile.layout.ConversionPattern = [\%d{HH:mm:ss}] \%-20c{2} \%m\%n

  );
        print $conf;
        Log::Log4perl::init( \$conf );

        unlink $socket_file;

        my $server = IO::Socket::UNIX->new(
            Type => SOCK_STREAM(),
            Local => $socket_file,
            Listen => 1,
        );

        LOGDIE "Can't create socket for server" unless defined $server;

        chdir("/") || LOGDIE "can't chdir to /: $!";
        open(STDIN, "< /dev/null") || LOGDIE "can't read /dev/null: $!";
        open(STDOUT, "> /dev/null") || LOGDIE "can't write to /dev/null: $!";

        my $watcher = CSS::Watcher->new;

        while (1) {
            my $clientsocket = $server->accept();

            print " **** New Client Connected ****\n";

            # read the data from the client
            my $task = <$clientsocket>;
            if (my ($watchobj) = $task =~/WATCH:(.+)/) {

                print "recieve job: \"$watchobj\"\n";

                my ($project_dir, $classes, $ids) = $watcher->update ($watchobj);
                if (defined $project_dir) {
                    print $clientsocket "PROJECT: $project_dir\n";
                    print "PROJECT: $project_dir\n";
                }
            }
        }
        $server->close();
        exit;
    }
    sleep 2;
    $client = IO::Socket::UNIX->new(
        Type => SOCK_STREAM(),
        Peer => $socket_file,
    );
    die "Can't create socket for client" unless defined $client;
}

# good, we connect to daemon, send job and print returned
print "Connected\n";
print $client "WATCH:$file\n";
my $response = <$client>;
if (defined $response) {
    print "$response\n";
}


# if (!defined ($client)) {
#     unlink $socket_file;

#     my $server = IO::Socket::UNIX->new(
#         Type => SOCK_STREAM(),
#         Local => $socket_file,
#         Listen => 1,
#     );

#     die "Can't create socket for server" unless defined $server;

#     my $watcher = CSS::Watcher->new;

#     while (1) {
#         my $clientsocket = $server->accept();

#         print " **** New Client Connected ****\n";

#         # read the data from the client
#         my $task = <$clientsocket>;
#         if (my ($watchobj) = $task =~/WATCH:(.+)/) {

#             print "recieve job: \"$watchobj\"\n";

#             my ($project_dir, $classes, $ids) = $watcher->update ($watchobj);
#             if (defined $project_dir) {
#                 print $clientsocket "PROJECT: $project_dir\n";
#                 print "PROJECT: $project_dir\n";
#                 print Dumper \$classes;
#             }
#         }
#     }
#     $server->close();
# } else {
#     print "Connected\n";
#     print $client "WATCH:$file\n";
#     my $response = <$client>;
#     if (defined $response) {
#         print "$response\n";
#     }
# }


# my $attrib_dir = File::Spec->catfile ($ac_html_stuff_dir, 'html-attributes-complete');
# rmtree $attrib_dir;
# mkpath $attrib_dir;

# while ( my ( $tag, $class ) = each %classes ) {
#     my $fname = File::Spec->catfile ($attrib_dir, $tag . '-class');
#     write_file ($fname, map {
#         $_ . ' ' . $class->{$_} } keys %{$class});
# }
# while ( my ( $tag, $id ) = each %ids ) {
#     my $fname = File::Spec->catfile ($attrib_dir, $tag . '-id');
#     write_file ($fname, map {
#         $_ . ' ' . $id->{$_} } keys %{$id});
# }
